Catalan Number: 1/(n+1)C(n, 2n) = f(0)*f(n) + f(1)*f(n-1) + f(2)*f(n-2) + ... + f(n)*f(0)
2^n - 1 = C(1, n) + C(2, n) + ... + C(n, n)
polynomial, exponential, Nth power of 2 (2^n)
dfs and bfs should consider VISITED to avoid circle accessing.

164. Maximum Gap (radix sort, bucket sort, time:n, space:n)

Permutations : https://leetcode.com/problems/permutations/
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        self.dfs(nums, 0, result)
        return result
        
    def dfs(self, nums, start, result):
        if start == len(nums):
            result.append(nums[:])
            return
        
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            self.dfs(nums, start+1, result)
            nums[start], nums[i] = nums[i], nums[start]
            
    def permute(self, nums):
        result = []
        self._permute(nums, [], result)
        return result
        
    def _permute(self, nums, path, result):
        if len(path) == len(nums):
            result.append(list(path))
        for num in nums:
            if num not in path:
                path.append(num)
                self._permute(nums, path, result)
                path.pop()
                
Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/

public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);
    return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){
    if(tempList.size() == nums.length){
        list.add(new ArrayList<>(tempList));
    } else{
        for(int i = 0; i < nums.length; i++){
            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;
            used[i] = true; 
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, used);
            used[i] = false; 
            tempList.remove(tempList.size() - 1);
        }
    }
}

Subsets : https://leetcode.com/problems/subsets/

public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, 0);
    return list;
}

private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){
    list.add(new ArrayList<>(tempList));
    for(int i = start; i < nums.length; i++){
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
}
Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/

public List<List<Integer>> subsetsWithDup(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, 0);
    return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){
    list.add(new ArrayList<>(tempList));
    for(int i = start; i < nums.length; i++){
        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates
        tempList.add(nums[i]);
        backtrack(list, tempList, nums, i + 1);
        tempList.remove(tempList.size() - 1);
    }
} 

Combination Sum : https://leetcode.com/problems/combination-sum/

public List<List<Integer>> combinationSum(int[] nums, int target) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, target, 0);
    return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){
    if(remain < 0) return;
    else if(remain == 0) list.add(new ArrayList<>(tempList));
    else{ 
        for(int i = start; i < nums.length; i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements
            tempList.remove(tempList.size() - 1);
        }
    }
}
Combination Sum II (can't reuse same element) : https://leetcode.com/problems/combination-sum-ii/

public List<List<Integer>> combinationSum2(int[] nums, int target) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, target, 0);
    return list;
    
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){
    if(remain < 0) return;
    else if(remain == 0) list.add(new ArrayList<>(tempList));
    else{
        for(int i = start; i < nums.length; i++){
            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, remain - nums[i], i + 1);
            tempList.remove(tempList.size() - 1); 
        }
    }
} 

Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/

public List<List<String>> partition(String s) {
   List<List<String>> list = new ArrayList<>();
   backtrack(list, new ArrayList<>(), s, 0);
   return list;
}

public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){
   if(start == s.length())
      list.add(new ArrayList<>(tempList));
   else{
      for(int i = start; i < s.length(); i++){
         if(isPalindrome(s, start, i)){
            tempList.add(s.substring(start, i + 1));
            backtrack(list, tempList, s, i + 1);
            tempList.remove(tempList.size() - 1);
         }
      }
   }
}

public boolean isPalindrome(String s, int low, int high){
   while(low < high)
      if(s.charAt(low++) != s.charAt(high--)) return false;
   return true;
} 

102. Binary Tree Level Order Traversal
    def levelOrderBFS(self, root):
        if not root:
            return []
        
        result = []
        q = collections.deque()
        q.append(root)
        while q:
            size = len(q)
            line = []
            for i in range(size):
                top = q.popleft()
                line.append(top.val)
                if top.left:
                    q.append(top.left)
                if top.right:
                    q.append(top.right)
            result.append(line)
        return result
        
    def levelOrderDFS(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        result = []
        self.dfs(root, 0, result)
        return result
       
    def dfs(self, root, level, result):
        if not root:
            return
        if level == len(result):
            result.append([])
        result[level].append(root.val)
        self.dfs(root.left, level+1, result)
        self.dfs(root.right, level+1, result)
        
109. Convert Sorted List to Binary Search Tree
    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        n, cur = 0, head
        while cur:
            n += 1
            cur = cur.next
        cur = [head]
        root = self.inorder(n, cur)
        return root
        
    def inorder(self, n, cur):
        if n <= 0:
            return None
        
        left = self.inorder(n//2, cur)
        root = TreeNode(cur[0].val)
        cur[0] = cur[0].next
        right = self.inorder(n - n//2 - 1, cur)
        root.left = left
        root.right = right
        return root

Convert Binary Search Tree (BST) to Sorted Doubly-Linked List
// This is a modified in-order traversal adapted to this problem.
// prev (init to NULL) is used to keep track of previously traversed node.
// head pointer is updated with the list's head as recursion ends.
void treeToDoublyList(Node *p, Node *& prev, Node *& head) {
  if (!p) return;
  treeToDoublyList(p->left, prev, head);
  // current node's left points to previous node
  p->left = prev;
  if (prev)
    prev->right = p;  // previous node's right points to current node
  else
    head = p; // current node (smallest element) is head of
              // the list if previous node is not available
  // as soon as the recursion ends, the head's left pointer 
  // points to the last node, and the last node's right pointer
  // points to the head pointer.
  Node *right = p->right;
  head->left = p;
  p->right = head;
  // updates previous node
  prev = p;
  treeToDoublyList(right, prev, head);
}
 
// Given an ordered binary tree, returns a sorted circular
// doubly-linked list. The conversion is done in-place.
Node* treeToDoublyList(Node *root) {
  Node *prev = NULL;
  Node *head = NULL;
  treeToDoublyList(root, prev, head);
  return head;
}

123. Best Time to Buy and Sell Stock III (at most two transactions)
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        buy1, sell1, buy2, sell2 = -sys.maxsize, 0, -sys.maxsize, 0
        for p in prices:
            buy1 = max(buy1, -p)
            sell1 = max(sell1, buy1+p)
            buy2 = max(buy2, sell1-p)
            sell2 = max(sell2, buy2+p)
        return sell2
188. Best Time to Buy and Sell Stock IV (at most k transactions)
    def maxProfit(self, k, prices):
        """
        :type k: int
        :type prices: List[int]
        :rtype: int
        """
        n = len(prices)
        if k <= 0 or not prices:
            return 0
        
        if k >= n // 2:
            profit = 0
            for i in range(1, n):
                if prices[i] > prices[i-1]:
                    profit += prices[i] - prices[i-1]
            return profit
        
        dp = [[0] * n for _ in range(k + 1)]
        for i in range(1, k + 1):
            maxbuy = -prices[0]
            for j in range(1, n):
                dp[i][j] = max(dp[i][j-1], maxbuy + prices[j])
                maxbuy = max(maxbuy, dp[i-1][j-1] - prices[j])
        return dp[k][n-1]
62. Unique Paths (only go right or down) (time: m*n, space: n)
class Solution {
    int uniquePaths(int m, int n) {
        if (m > n) return uniquePaths(n, m);
        vector<int> cur(m, 1);
        for (int j = 1; j < n; j++)
            for (int i = 1; i < m; i++)
                cur[i] += cur[i - 1]; 
        return cur[m - 1];
    }
}; 

127. Word Ladder (time:M*N, space:M*N, where M is length of word, N is word count)
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """

        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        # Since all words are of same length.
        L = len(beginWord)

        # Dictionary to hold combination of words that can be formed,
        # from any given word. By changing one letter at a time.
        all_combo_dict = defaultdict(list)
        for word in wordList:
            for i in range(L):
                # Key is the generic word
                # Value is a list of words which have the same intermediate generic word.
                all_combo_dict[word[:i] + "*" + word[i+1:]].append(word)


        # Queue for BFS
        queue = [(beginWord, 1)]
        # Visited to make sure we don't repeat processing same word.
        visited = {beginWord: True}
        while queue:
            current_word, level = queue.pop(0)      
            for i in range(L):
                # Intermediate words for current word
                intermediate_word = current_word[:i] + "*" + current_word[i+1:]

                # Next states are all the words which share the same intermediate state.
                for word in all_combo_dict[intermediate_word]:
                    # If at any point if we find what we are looking for
                    # i.e. the end word - we can return with the answer.
                    if word == endWord:
                        return level + 1
                    # Otherwise, add it to the BFS Queue. Also mark it visited
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level + 1))
                all_combo_dict[intermediate_word] = []
        return 0

126. Word Ladder II
    def findLadders(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        """
        if not beginWord or not endWord or not wordList or endWord not in wordList:
            return []
        
        result = []
        wlen = len(wordList[0])
        nextWords = collections.defaultdict(list)
        for word in wordList:
            for i in range(wlen):
                pattern = word[:i] + '*' + word[i+1:]
                nextWords[pattern].append(word)
        distance = {}
        self.bfs(beginWord, endWord, nextWords, distance)
        print(distance)
        self.dfs(beginWord, endWord, nextWords, distance, [], result)
        return result
                
        
    def bfs(self, beginWord, endWord, nextWords, distance):
        distance[beginWord] = 0
        q = collections.deque()
        q.append(beginWord)
        lastFound = False
        while q:
            size = len(q)
            for _ in range(size):
                top = q.popleft()
                for i in range(len(beginWord)):
                    pattern = top[:i] + '*' + top[i+1:]
                    for word in nextWords[pattern]:
                        if word not in distance:
                            distance[word] = distance[top] + 1
                            q.append(word)
                            if word == endWord:
                                lastFound = True
            if lastFound:
                break
    
    def dfs(self, beginWord, endWord, nextWords, distance, path, result):
        path.append(beginWord)
        if beginWord == endWord:
            result.append(list(path))
        for i in range(len(beginWord)):
            pattern = beginWord[:i] + '*' + beginWord[i+1:]
            for word in nextWords[pattern]:
                if word in distance and distance[word] == distance[beginWord] + 1:
                    self.dfs(word, endWord, nextWords, distance, path, result)
        path.pop()
        
132. Palindrome Partitioning II
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        for i in range(len(s)):
            for j in range(i, -1, -1):
                k = i + i - j
                if k >= len(s) or s[j] != s[k]:
                    break
                if k - j + 1 > len(result):
                    result = s[j:k+1]
                    
            for j in range(i, -1, -1):
                k = i + i - j + 1
                if k >= len(s) or s[j] != s[k]:
                    break
                if k - j + 1 > len(result):
                    result = s[j:k+1]
        return result
